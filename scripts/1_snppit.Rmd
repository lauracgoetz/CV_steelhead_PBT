---
title: "1_CVSH: SNPPIT"
output: html_notebook
---

# Overview

We collected nonlethal genetic samples from finclips from all steelhead spawned at the four CV hatcheries producing steelhead (Coleman National Fish Hatchery, Feather River Hatchery, Mokelumne River Hatchery, Nimbus Fish Hatchery) from 2011-2019. Fish were genotyped with 96 SNPs, but which loci were used changed over the sampling period. The following loci were removed before PBT/other analyses:

- Omy_R04944 (Omy05 genotypes, saved as ../metadata/omy05_genos.csv)
- SexID (used for determining Genetic_Sex > Sex)
- SH128851-273 - MendIncLoci error rate over 2%
- SH131965-120 - MendIncLoci error rate over 2%

To reconstruct a pedigree from the samples using SNPPIT, we must: 

1. Standardize program names and remove inconsistent loci
2. Identify individuals that were re-genotyped and consolidate those duplicated IDs
3. Produce both a metadata and genotype dataset for running SNPPIT
4. Remove samples missing more than 10% of loci
5. Matching Sample Analysis (MSA) 
6. Run SNPPIT, save results, reconstruct pedigree

There were 23,753 total samples, with 83 samples being duplicated, so 23,670 samples were received over the years. 422 samples were removed for missing more than 10% of loci, leaving 23,248 samples. Removing steelhead missing genetic and phenotypic sex left 23,239 samples for pedigree reconstruction. The MSA identified 4,119 fish in a cluster. 19,021 unique steelhead were identified by the SNPPIT runs. 


```{r}
library(tidyverse)
library(ggplot2)

cvsh <- read_rds("../metadata/cvsh.rds") %>% select(-(`SH128851-273`), -(`SH128851-273_1`))  

# 23,753 total samples, two loci already removed: Sex_ID and Omy_R04944 
```


# Remove sample duplicates

The best rendition of an individual to keep is the one with the most genotyped SNPs. Load in the metadata in two-column format and use these steps to remove genotype duplicates. 

Of the 23,753 genotypes we started with, 83 were duplicated samples, so 23,670 total samples received from hatcheries.

```{r}
# first identify which rendition of an individual to keep
## filter to everyone with duplicated IDs
## reformat so 1st column is IDs and 2nd column starts genotypes
rendition_genos <- cvsh %>%
  count(NMFS_DNA_ID) %>%
  filter(n != 1) %>%
  semi_join(cvsh, ., by = "NMFS_DNA_ID") %>%
  group_by(NMFS_DNA_ID) %>%
  mutate(rendition = 1:n()) %>%
  select(rendition, everything()) %>%
  select(-(BOX_ID:NMFS_ID_VLOOKUP))

# count up how many duplicated
counts <- rendition_genos %>% group_by(NMFS_DNA_ID) %>% count() %>% rename("redos"="n")
counts <- counts %>% group_by(redos) %>% count()
# 1 sample was rerun 3x, 81 samples were rerun 2x


keepers <- rendition_genos %>%
  gather(key = "locus", value = "allele_int", -rendition, -NMFS_DNA_ID) %>%
  group_by(NMFS_DNA_ID, rendition) %>%
  summarise(num_non_miss = sum(allele_int != 0) / 2) %>%
  arrange(NMFS_DNA_ID, desc(num_non_miss)) %>%
  slice(1)

# make a wide genos data frame of those individuals
final_dupie_genos <- rendition_genos %>%
  semi_join(keepers, by = c("NMFS_DNA_ID", "rendition")) %>%
  ungroup() %>%
  select(-rendition)

# now, we want to make a similar wide file of all the rest,
# dropping the ones that were duplicated.
non_duped_genos <- cvsh %>%
  anti_join(rendition_genos, by = "NMFS_DNA_ID") %>%
  select(-(BOX_ID:NMFS_ID_VLOOKUP))

wide_genos <- bind_rows(non_duped_genos, final_dupie_genos)
# 23,670 samples received total
```

```{r}
# save to rds
write_rds(wide_genos, path = "../metadata/all_wide_genos.rds", compress = "xz")
```


# Produce genotype and metadata datasets

To run SNPPIT using HatchPedAgree, we need separate datasets with the spawner metadata and genotypes. 

## Produce Genotype Dataset

Convert file so each locus has its own two rows for each allele. Each ID will have two rows for each locus, one for each gene copy. 

```{r}
# need NMFS_DNA_ID, locus, gene_copy, and allele_int - takes a min
cvsh_geno <- wide_genos %>% 
  gather(key = "locus", value = "allele_int", -NMFS_DNA_ID) %>%
  mutate(locus = str_replace(locus, "_1$", "")) %>% 
  group_by(NMFS_DNA_ID, locus) %>%
  mutate(gene_copy = 1:2) %>%
  mutate(allele_int = as.integer(allele_int)) %>%
  rename(indiv = NMFS_DNA_ID) %>%
  ungroup()


cvsh_geno <- cvsh_geno %>% 
  select(indiv, locus, gene_copy, allele_int)

cvsh_geno[cvsh_geno == 0]<-NA
```

```{r}
# number of loci used: 92
no.loci <- cvsh_geno %>% 
  select(locus) %>% 
  distinct()

write_csv(no.loci, "../tables/1_PBT_loci.csv")
```


## Produce Metadata Dataset

### Check/resolve sex conflicts 

```{r}
# need NMFS_DNA_ID, sex, spawner_group, year, hatchery
## create sex column from Genetic_Sex and SEX (phenotypic) columns

cvsh_meta_sex_check <- cvsh %>% 
  select(NMFS_DNA_ID:NMFS_ID_VLOOKUP) %>%
  filter(!duplicated(NMFS_DNA_ID)) %>% 
  group_by(Genetic_Sex) %>% 
  count(SEX)
```  
  
  
Methods:

  Our panel included a Y-chromosome marker (Butelli et al. 2008) that was used before analyses for determining sex in addition to hatchery-recorded sexes. Sex genotypes were accepted as the correct sex when possible, even when contradicting recorded phenotypic sex. For samples that failed to genotype for our sex marker, we accepted phenotypic sex as the correct sex.


Results:

  Conflicts for sexes:
- 2,514 samples with unknown genetic sex (phenotypic sex: female = 1,150, male = 1,351, NA = 13) - accept phenotypic sex
- 15 samples missing phenotypic sex (genetic sex: female = 1, male = 1, ? = 13) - accept genetic sex
- 364 with explicit mismatches between genetic and phenotypic sex (190 = genetic F:pheno M; 174 = genetic M:pheno F) - accept genetic sex

  No conflict:
- 10,035 females as females
- 10,755 males as males


  20,790 samples had matching genetic and phenotypic sexes, with 2,880 samples missing genetic and/or phenotypic sex or having mismatches between genotype and phenotype. 2,514 samples were missing sex genotypes but had recorded phenotypic sex, 15 samples were missing phenotypic sex, and 364 samples had mismatches between genetic and phenotypic sexes. 13 samples were missing both genetic and phenotypic sex. 
  

```{r}
cvsh_meta <- cvsh %>% 
  select(NMFS_DNA_ID:NMFS_ID_VLOOKUP) %>%
  filter(!duplicated(NMFS_DNA_ID)) %>%
  mutate(
    indiv = NMFS_DNA_ID,
    spawner_group = COLLECTION_DATE,
    sex = case_when(
      Genetic_Sex == "?" ~ paste(SEX),
      is.na(SEX) ~ paste(Genetic_Sex),
      Genetic_Sex != "?" ~ paste(Genetic_Sex),
      TRUE ~ paste(SEX)),
    year = CollectionYear,
    hatchery = SNPPIT.Descriptor
  ) %>%
  select(indiv:hatchery, everything())

# number by hatchery and year
meta_count <- cvsh_meta %>%   
  group_by(hatchery, year) %>% 
  count() %>% 
  group_by(hatchery) %>% 
  mutate(total = sum(n))
```

```{r}
# write to rds
write_rds(cvsh_geno, path = "../metadata/samples_geno.rds", compress = "xz")
write_rds(cvsh_meta, path = "../metadata/samples_meta.rds", compress = "xz")
write_csv(meta_count, "../processed_data/1_sample_count.csv")
```



Number of Samples

```{r}
# plotting settings are for posters rn - likely change
samples_fig <- ggplot(meta_count)+
  geom_line(aes(x=year, y=n, color =hatchery))+
  labs(x = " ", y = "Samples")+
  scale_color_manual(values =c("#9379AD", "#e4af62", "#b65d2b", "#79ad9f"))+
  scale_x_continuous(name = " ", breaks = seq(2011,2019,by=1))+
  theme_classic()+ 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
         legend.position = "none",
        axis.title=element_text(size=8),
        axis.text=element_text(size=6))+
  guides(color=guide_legend(title=""))+
  ggtitle(" ")
samples_fig
```



# Remove High Missers

we need to remove individuals missing data at more than 10%. Also confirm that all fish have 92 loci. We set the non-missing locus cutoff to >= 83 loci.  That is about 10% missing from all loci, and means we toss 1.78% of our samples - or 422 total samples. 

Very important to change 0s to NAs! This step won't work otherwise. 

```{r}
miss_dsn <- cvsh_geno %>%
  group_by(indiv) %>%
  summarise(
    num_all_loci = n() / 2,  # check to make sure each gene copy is explicitly listed as NA
    num_non_miss_loci = sum(!is.na(allele_int)) / 2)

count(miss_dsn, num_all_loci)  

full_histo <- ggplot(miss_dsn, aes(x = num_non_miss_loci)) +
  geom_histogram(binwidth = 1)+
  xlim(0,100)
full_histo

```



Zoom in on that a bit:
```{r}
full_histo +
  ylim(0, 1000)
```

How many fish would different cutoffs remove?  Let's see what different choices would give us in terms
of how many individuals are retained/removed:
```{r}
count_miss <- miss_dsn %>%
  count(num_non_miss_loci) %>%
  arrange(desc(num_non_miss_loci)) %>%
  mutate(
    fract_retained = cumsum(n) / sum(n),
    fract_tossed = 1 - fract_retained
    )
 
```

```{r}
meta <- cvsh_meta %>%
  semi_join(miss_dsn %>% filter(num_non_miss_loci >= 83), by = "indiv")
# determine number by program
miss_pro <- semi_join(cvsh_meta, miss_dsn%>% filter(num_non_miss_loci < 83), by="indiv") %>% 
  group_by(hatchery) %>% 
  count() %>% 
  ungroup() %>% 
  mutate(total = sum(n))
genos <- cvsh_geno %>%
  semi_join(miss_dsn %>% filter(num_non_miss_loci >= 83), by = "indiv")
```


# Matching Sample Analysis (MSA)

Now that the necessary columns and duplicates have been removed, it's time to identify which samples come from the same individual. It is common for hatcheries to respawn males in the same broodyear (repeat-spawning), and the same fish over multiple years (iteroparity). It's important to identify each instance an individual is reused, as it affects pedigree reconstruction. 

In this step, these samples are identified and connected into clusters with each individual's uses over the dataset's years. The timing of each spawning event of an individual will determine if that individual is later included in each snppit analysis as an offspring or parent. This analysis will be used to identify iteroparous and repeat-spawners. 

The next steps use the package HatcheryPedAgree (https://github.com/eriqande/HatcheryPedAgree).
```{r}
library(HatcheryPedAgree)

# first time through, just get the distribution of matching proportions
for_histo <- find_matching_samples(genos, min_frac_matching = 0.8)

# check the distribution
for_histo$pairs %>%
  mutate(frac_match = num_match / num_non_miss) %>%
  ggplot(aes(x = frac_match)) +
  geom_histogram()+
  ggtitle("Matching Sample Analysis") 

msa <- for_histo$pairs %>%
  mutate(frac_match = num_match / num_non_miss) %>%
  ggplot(aes(x = frac_match)) +
  geom_histogram()+
  ggtitle("Matching Sample Analysis")


ggsave(plot = msa, file = "../figures/S2_msa.png", 
       #bg = "transparent",
       width = 20, height = 15, units = "cm", dpi = 800)

ggsave(plot = msa, file = "../final_figures/S2_msa.pdf", 
       width = 180, height = 135, units = "mm", dpi = 600)

# get the clusters of matching genotypes each indvidual belongs to
for_real <- find_matching_samples(genos, min_frac_matching = 0.95, return_clusters = TRUE)

# we will end up using the identified clusters
head(for_real$clusters)
```

# Reorganizing for SNPPIT

Remove the individuals missing sex ids from both meta and genos before running SNPPIT. Removing these 9 samples reduced the dataset from 23,248 samples to 23,239 samples. 

```{r}
# remove sex = NA 
meta_sexd <- meta %>% 
  filter(sex != "NA")

# check what missing sex
meta_sex_check <- meta %>% 
  filter(sex == "NA")

genos_sexd <- genos %>% 
  filter(indiv %in% meta_sexd$indiv)
```



At this point, `for_real$clusters` is the tibble we need to re-organize our genotypes and meta-data for SNPPIT.  For every cluster of matching samples we will use, as the genotype, the sample with the least missing data.  We will also use the sex of that individual (sometimes there are mismatches in the sex of the matching genotypes).  Sometimes there are mismatches in the hatchery of the matching genotypes.  In those cases, each separate hatchery gets its own canonical individual named as the ID of the main canonical individual with the hatchery name appended to it.  The following function takes care of this and reorganizes both the genotypes and also the meta data into `snppit_genos` and `snppit_meta` (as well as a few other list components).

```{r}
reorg <- reorganize_matching_samples(
  genotypes = genos_sexd, 
  metadata = meta_sexd, 
  clusters = for_real$clusters
)
```


### `matchers_metadata`

This is the meta data for all the matching genotypes.  Column `original_id` shows what they
were named on input, and column `new_id` shows the ID used to identify them now in the
SNPPIT-ready output.
```{r}
reorg$matchers_metadata

```

### `snppit_meta` and `snppit_genos`

These are the tibbles that are ready to pass into `prepare_snppit_infile()`.  Multiple
years and spawner_groups of the matching individuals have been lumped into
comma-separated strings for the year and spawner group inputs to SNPPIT.

### `cross_hatchery_matches` 

A tibble that shows you which clusters of matching genotypes included fish from more
than one hatchery.
```{r}
reorg$cross_hatchery_matches

```

### `cross_sex_matches` 

A tibble that shows you which clusters of matching genotypes included fish with more than
one reported sex (19). 19 clusters containing 46 samples had both sexes recorded in the matching sample analysis. These individuals were removed from pedigree reconstruction and all analyses. 

```{r}
d<- reorg$cross_sex_matches
f<- reorg$geno_discord$alt_homoz_mismatches

# meta_final 
meta_final <- meta_sexd %>% 
  filter(!(indiv %in% d$retained_id)) %>% 
  filter(!(indiv %in% d$original_id)) %>% 
  filter(!(indiv %in% f$retained_id)) %>% 
  filter(!(indiv %in% f$original_id))

# genos_final
genos_final <- genos_sexd %>% 
  filter(indiv %in% meta_final$indiv)

# number by hatchery and year
meta_final_count <- meta_final %>%   
  group_by(hatchery, year) %>% 
  count() %>% 
  group_by(hatchery) %>% 
  mutate(total = sum(n))

clust <- reorg$matchers_metadata
clust_final <- clust %>% 
  filter(!(cluster %in% d$cluster)) %>% 
  filter(!(retained_id %in% f$retained_id)) %>% 
  rename("indiv"="NMFS_DNA_ID")
clust_count <- clust_final %>% 
  distinct(cluster)

# save this to file for iteroparous and reused spawner analyses
write_rds(clust, path ="../metadata/clusters.rds", compress = "xz")

# save meta_sexd and genos_sexd for population genetics analyses
# write to rds
write_rds(genos_final, path = "../metadata/cvsh_geno.rds", compress = "xz")
write_rds(meta_final, path = "../metadata/cvsh_meta.rds", compress = "xz")
write_csv(meta_final_count, "../processed_data/1_pbt_count.csv")

# save this to file for sexes to drop from sex-specific analyses
write_rds(d, path ="../metadata/sex_conflict.rds", compress = "xz")
```

We now have 23,191 samples to reconstruct the pedigree from, with 4,069 samples coming from 1,898 steelhead that spawned more than once. 

## Summary Table
```{r}
finclips <- meta_count %>% 
  rename("fin clips" = "n")
genotyp <- meta %>% 
  group_by(SNPPIT.Descriptor, CollectionYear) %>% 
  count() %>% 
  rename("hatchery" = "SNPPIT.Descriptor", "year" = "CollectionYear", "genotyped" = "n")
pbt <- meta_final_count %>% 
  select(-total) %>% 
  rename("PBT" = "n")

table1 <- left_join(finclips,genotyp, by=c("hatchery","year")) %>% 
  left_join(., pbt, by=c("hatchery","year")) 

table1a <- table1 %>%
  group_by(hatchery) %>% 
  mutate(total_geno = sum(genotyped), pivot_col = "total genotyped") %>% 
  select(hatchery, total_geno, pivot_col) %>% 
  distinct() %>% 
  pivot_wider(names_from = hatchery, values_from = total_geno)

table1b <- table1 %>% 
  select(hatchery, total) %>% 
  distinct() %>% 
  mutate(pivot_col = paste("total sampled")) %>% 
  pivot_wider(names_from = hatchery, values_from = total)

table1c <- table1 %>% 
  select(hatchery, year, genotyped) %>% 
  rename("pivot_col"="year") %>% 
  pivot_wider(names_from = hatchery, values_from = genotyped)

table1f <- rbind(table1a, table1b) %>% 
  rbind(., table1c)
  
  
write_csv(table1f, "../tables/1_samples.csv")

write_csv(reorg$cross_hatchery_matches, "../processed_data/cross_hatchery_matches.csv")
```


## Reorganize for SNPPIT with final files
```{r}
reorg <- reorganize_matching_samples(
  genotypes = genos_final, 
  metadata = meta_final, 
  clusters = clust_final
)
```



# Prepare a SNPPIT infile and run it through SAD (constrained by sex and date) run

We have rolled these two steps into a single run_snppit() function.

Internally, it calls `prepare_snppit_infile()` to write the data,
and then it runs `snppit` inside the `system()` command.

Here is what that looks like:
```{r}
snppit_dir1 <- run_snppit(reorg$snppit_genos, reorg$snppit_meta)

snppit_dir1

## Slurp up the results

# here we call the "constrained" runs SAD for "sex_and_date"
SAD_results <- slurp_snppit(snppit_dir1, reorg$snppit_meta)
write_rds(SAD_results, path = "../processed_data/CV_SAD_results.rds", compress = "xz")
```


# Unconstrained or "noSAD" run


```{r}
snppit_dir_noSAD <- run_snppit(
  reorg$snppit_genos, 
  reorg$snppit_meta, 
  use_spawner_group = FALSE,
  use_sex = FALSE
  )

no_SAD_results <- slurp_snppit(snppit_dir_noSAD, reorg$snppit_meta)
write_rds(no_SAD_results, path="../processed_data/CV_no_SAD_results.rds", compress = "xz")

```

# Compare SNPPIT Runs

To finalize the pedigree, the constrained and unconstrained runs will be compared to see if offspring are assigned same parents in both runs or not / if offspring are not assigned parents in a run. We can also identify various problems, like two sexes assigned as parents, etc. Here's copy and paste from Eric's HatcheryPedAgree development notes:

## HPA summary of trio categories

This is primarily used for identifying the different combinations
of results that you might see when comparing SAD (with Sex And Date)
to noSAD (without Sex and Date) runs.  Typically you will pass the results of the SAD run in as Run1 to the function and the results of the noSAD run in as Run2.  For each run you can set a different FDR threshold to use when the function is partioning things, but I suspect that it will be typical to set FDR1 = 0.01 and FDR2 = 0.01.  


This function simply explicitly partitions each kid from the pedigree inference project into a group based on characteristics of the inference of its parents in the two different snppit runs.  I find this easier to look at and think about than trees depicting filtering decision points that may or may not represent actual partitions.

Briefly, the partition of these individuals is based on just a few binary characteristics of each kid within each run.  

Namely:

1. Does the kid have any inferred parents, or none (i.e. NA) in Run1 and in Run2?  If it doesn't have any inferred parents in a run, then the later criteria (2, 3, and 4 are
largely moot).

2. Did the trios in Run1 and Run2 enjoy having their maximum posterior trio category be C_Se_Se, or not?

3. Was the trio found at an FDR below a certain threshold for each run?

And finally, a fourth criterion that is not binary like the first three, and, further, is also a property of the comparison between the trios found for a kid in the two different runs, rather than being a property that can be associated with just a single run:

4. How many parents are shared for the kid between the two runs, with possible answers 0 = (none!), 1 = just a single parent is shared, 2 = the same two parents are inferred in the two runs, or NA = in one or both of the runs the kid was not found to have a parent.

The total number of possible categories from criteria 1--3 that a kid in a single run can belong to is: 1 (for NA) + 1 * 2 * 2.  So, at the first 3 criteria between the two Runs there are 25 different categories possible.  

Of those, 16 involve cases where parents are NA in neither run.  And in those cases there are three possible numbers of matching parents (0, 1, or 2), which turns those 16 into a possible 48 cases. Hence, we are partitioning the kids/trios up into 48 + 9 = 57 possible categories with these few criteria.

Once you get the number in each of those categories, seeing them all out there in a way that adds up to the actual number of kids makes it a lot easier to think about which trios you want to retain and which you don't. In fact, as we will see, we can just add a column which says, for each partition, whether you want to retain the trio from Run1, from Run2, or from Neither, then feed that back to pick out the trios you want.  (I haven't implemented that yet, but it will be easy).


```{r}
sad <- SAD_results # 19,043 trios found
no <- no_SAD_results # 19,043 trios found


snp_comp1 <- SAD_results %>% 
  select(kid, ma, pa, MaxP.Pr.Relat, FDR, ma_hatchery, kid_hatchery, ma_year, kid_year, ma_sg, pa_sg) %>% 
  rename("ma1"="ma", "pa1"="pa", "MaxP.Pr.Relat1"="MaxP.Pr.Relat", "FDR1"="FDR", "mahat1"="ma_hatchery", "kihat1"="kid_hatchery", "mayr1"="ma_year", "kiyr1"="kid_year", "masg1"="ma_sg", "pasg1"="pa_sg")

snp_comp2 <- no_SAD_results %>% 
  select(kid, ma, pa, MaxP.Pr.Relat, FDR, ma_hatchery, kid_hatchery, ma_year, kid_year, ma_sg, pa_sg) %>% 
  rename("ma2"="ma", "pa2"="pa", "MaxP.Pr.Relat2"="MaxP.Pr.Relat", "FDR2"="FDR", "mahat2"="ma_hatchery", "kihat2"="kid_hatchery", "mayr2"="ma_year", "kiyr2"="kid_year", "masg2"="ma_sg", "pasg2"="pa_sg")

snp_comp <- left_join(snp_comp1, snp_comp2, by="kid") %>% 
   mutate(no_matching_par = case_when(
          (ma1==ma2) & (pa1==pa2) | (ma1 == pa2) & (pa1==ma2) ~ 2,
          ((ma1!=ma2) & (pa1==pa2) | (ma1==ma2) & (pa1!=pa2)) | ((ma1 != pa2) & (pa1==ma2) | (ma1 == pa2) & (pa1!=ma2)) ~ 1,
          (ma1!=ma2) & (pa1!=pa2) | (ma1 != pa2) & (pa1!=ma2) ~ 0,
          is.na(ma1) | is.na(pa1) | is.na(ma2) | is.na(pa2) ~ NA),
        MaxP.check = case_when(
          MaxP.Pr.Relat1 == "C_Se_Se" & MaxP.Pr.Relat2 == "C_Se_Se" ~ paste("both"),
          MaxP.Pr.Relat1 == "C_Se_Se" & MaxP.Pr.Relat2 != "C_Se_Se" ~ paste("sad"),
          MaxP.Pr.Relat1 != "C_Se_Se" & MaxP.Pr.Relat2 == "C_Se_Se" ~ paste("no"),
          MaxP.Pr.Relat1 != "C_Se_Se" & MaxP.Pr.Relat2 != "C_Se_Se" ~ paste("none"),
          is.na(MaxP.Pr.Relat1) & MaxP.Pr.Relat2 == "C_Se_Se" ~ paste("NA sad, no"),
          is.na(MaxP.Pr.Relat1) & MaxP.Pr.Relat2 != "C_Se_Se" ~ paste("NA sad, none")),
        FDR.check = case_when(
          FDR1 <= 0.01 & FDR2 <= 0.01 ~ paste("both"),
          FDR1 <= 0.01 & FDR2 > 0.01 ~ paste("sad"),
          FDR1 > 0.01 & FDR2 <= 0.01 ~ paste("no"),
          FDR1 > 0.01 & FDR2 > 0.01 ~ paste("none"),
          is.na(FDR1) & FDR2 <= 0.01 ~ paste("NA sad, no"),
          is.na(FDR1) & FDR2 > 0.01 ~ paste("NA sad, none"))) %>%
  left_join(., meta_sexd %>% select(indiv, sex) %>% rename("ma1_sex"="sex"), by=c("ma1"="indiv")) %>% 
  left_join(., meta_sexd %>% select(indiv, sex) %>% rename("pa1_sex"="sex"), by=c("pa1"="indiv")) %>% 
  left_join(., meta_sexd %>% select(indiv, sex) %>% rename("ma2_sex"="sex"), by=c("ma2"="indiv")) %>% 
  left_join(., meta_sexd %>% select(indiv, sex) %>% rename("pa2_sex"="sex"), by=c("pa2"="indiv")) %>% 
  mutate(par_sexd = paste(ma1_sex, pa1_sex, ";", ma2_sex, pa2_sex)) %>% 
  mutate(keep_trio = case_when(
    no_matching_par == 2 & MaxP.check == "both" & FDR.check == "both" & ma1_sex != pa1_sex & ma2_sex != pa2_sex ~ "all good",
    no_matching_par == 2 & MaxP.check == "both" & FDR.check == "sad" & ma1_sex != pa1_sex & ma2_sex != pa2_sex ~ "all good",
    is.na(no_matching_par) & MaxP.check == "NA sad, no" & FDR.check =="NA sad, no" & ma2_sex != pa2_sex ~ "NA sad; no SAD ok",
    TRUE ~ "toss"
  ))

snp_cnt <- snp_comp %>% 
  group_by(no_matching_par, MaxP.check, FDR.check, par_sexd) %>% 
  count(keep_trio)

snp_cnt_b <- snp_comp %>% 
  group_by(no_matching_par, MaxP.check, FDR.check, par_sexd) %>% 
  count()

snp_cnt_c <- snp_comp %>% 
  count(keep_trio)

snp_cnt_d <- snp_comp %>% 
  filter(MaxP.Pr.Relat1 == "C_Se_Se" & FDR1 <= 0.01) #13657

```


Both runs found 19,043 unique kids from 23,191 samples - 2,830 samples were unassigned parents, mainly 2011-2012 steelhead from all programs and 2013 from NH (more than 2,000 out of 2,830)

```{r}
# count unassigned by program and year
unassigned_ct <- snp_comp %>% 
  filter(is.na(ma1), is.na(pa1), is.na(ma2), is.na(pa2)) %>% 
  count(kiyr1, kihat2)


# this is largely from sampling starting in 2011
unassigned_sep_ct <- snp_comp %>% 
  filter(is.na(ma1), is.na(pa1), is.na(ma2), is.na(pa2)) %>% 
  separate_rows(kiyr1, sep=",") %>% 
  count(kiyr1, kihat2)
```


We found 13,657 trios with supporting stats
  supporting stats: MaxP.Pr.Relat == "C_Se_Se" and FDR <= 0.01
  

* 12,774; 93.53% (9503+3271) offspring were assigned the same parents in both runs with supporting stats and sexes in both 
* 818 (600+218) offspring were assigned the same parents in both runs with supporting sexes in both and supporting stats in constrained (sad) run 

12,774+818 = 13,592 / 13,624 original trios retained with correct sexes

16 of these trios have kid_year in 2012 which isn't possible (no 1 yo spawning; likely from inbreeding) - so filter those out too

SO total # of remaining trios = 13,576 with confident assignments
  

```{r}
trios_keep <- snp_comp %>% 
  filter(keep_trio == "all good") 

pedigree <- SAD_results %>% 
  filter(kid %in% trios_keep$kid) %>% 
  filter(kid_year != 2012) 

write_rds(pedigree, "../processed_data/CV_pedigree.rds")
```


